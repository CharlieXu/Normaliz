Dinge die man von einem FullCone erfahren kann:

generators
extreme_rays
support_hyperplanes
triangulation
multiplicity
ht1_elements
hilbert_basis
hvector
hilbert_polynomial

is_pointed
is_ht1_generated       | schlechte namen
is_ht1_triangulated(?) |
is_ht1_extreme_rays    | 

Zu jedem der vorherigen Punkte, ob es bereits berechnet wurde/durch Eingabe vorhanden ist. Das sollte den status string ersetzen. 



Einzeloperationen die ein FullCone kann:

compute_support_hyperplanes
compute_support_hyperplanes_pyramid
check_pointed
compute_extreme_rays
check_generators_ht1
check_extreme_rays_ht1
compute_support_hyperplanes_triangulation
compute_support_hyperplanes_triangulation_pyramid
compute_support_hyperplanes_partial_triangulation     (Ähnlich wie eine Pyramiden Methode)
compute_multiplicity
compute_ht1_elements          | 
compute_ht1_elements_hvector  |  berechnen auch jeweils
compute_candidates            |  die Multiplizität
compute_candidates_hvector    |  candidates beinhaltet auch immer ht1 elements
compute_hilbert_basis   = global_reduction
compute_polynomial

Die _pyramid Funktionen wenden auf oberster Ebene nur eine Unterteilung in Pyramiden an und rufen für diese die "normalen" Funktionen auf. Das kann aber später noch um eine Steuerung per Parameter oder eine Automatik erweitert werden.


Im Constructor:
Rangtest, make_prime, Nullzeilen entfernen

"computation types":

support_hyperplanes:
  compute_support_hyperplanes
  check_pointed
   |-- nein -> Ende
  compute_extreme_rays
  check_generators_ht1
  check_extreme_rays_ht1


triangulation:
  compute_support_hyperplanes_triangulation
  check_pointed
   |-- nein -> Ende
  compute_extreme_rays
  check_generators_ht1
  check_extreme_rays_ht1
  is_ht1_generated (oder triangulated)
   |-- nein -> Ende  (oder wenn is_ht1_extreme_rays dann mit denen neu triangulieren? Dazu könnte man sie einfach umsortieren)
  compute_multiplicity
  

normal:
  compute_support_hyperplanes_triangulation
  check_pointed
   |-- nein -> Ende
  compute_extreme_rays
  check_generators_ht1
  check_extreme_rays_ht1
  is_ht1_generated (oder triangulated)
   |-- nein -> compute_candidates               | Unterscheidung evtl
	|--  ja  -> compute_candidates_multiplicity  | nicht nötig
  compute_hilbert_basis

normal_partial_triangulation:
  compute_support_hyperplanes_partial_triangulation
  check_pointed
   |-- nein -> Ende
  compute_extreme_rays
  check_generators_ht1
  check_extreme_rays_ht1
  compute_candidates
  compute_hilbert_basis

heigth_1_elements:
  compute_support_hyperplanes_partial_triangulation  (oder volle?)
  check_pointed
   |-- nein -> Ende
  compute_extreme_rays
  check_generators_ht1
  check_extreme_rays_ht1
  compute_ht1_elements_multiplicity

hilbert_basis_polynomial:
  compute_support_hyperplanes
  check_pointed
   |-- nein -> Ende
  compute_extreme_rays
  check_generators_ht1
  check_extreme_rays_ht1
  triangulation_lift
  | lift
  | | compute_support_hyperplanes_dynamic
  | | low_part_simplicial               //check and erase upper facets 
  | line_shelling 
  find_new_face
  compute_candidates_hvector
  compute_hilbert_basis
  compute_hilbert_polynomial


hilbert_polynomial:
  compute_support_hyperplanes
  check_pointed
   |-- nein -> Ende
  compute_extreme_rays
  check_generators_ht1
  check_extreme_rays_ht1
  triangulation_lift
  | lift
  | | compute_support_hyperplanes_dynamic
  | | low_part_simplicial               //check and erase upper facets 
  | line_shelling 
  find_new_face
  compute_hvector
  compute_hilbert_polynomial






Hilfsoperationen:

transform_values
add_hyperplane
reduce_and_insert   Verschiedene Ausführungen
und viele andere
